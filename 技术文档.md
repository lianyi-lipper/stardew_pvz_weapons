# 问题复盘与分析

## 问题描述

### 初始问题

在开发星露谷物语Mod时，希望实现穿透发射物（电能超级机枪射手）能够摧毁树木的功能，但遇到以下问题：

1. **树木无倒下动画**：树木被击中后直接消失或延迟消失，没有原版游戏的倒下动画
2. **树桩立即消失**：即使树木倒下，树桩也会立即消失，无法像原版一样保留
3. **掉落物数量错误**：木材掉落数量不正确，有时过多（重复掉落）
4. **树桩无法摧毁**：在某些修复尝试后，树桩变得完全无法被第二次攻击摧毁

### 期望行为

1. 树木被击中后播放倒下动画（约2秒）
2. 动画结束后留下树桩
3. 掉落正确数量的木材和种子（12木材 + 1种子+树液等）
4. 树桩可以被第二次攻击摧毁

## 根本原因

### 核心问题1：不了解游戏引擎的树木销毁机制

**错误理解**：认为只需设置树木的标志位（`falling`, `health`, `stump`）即可触发正确的倒下流程。

**实际情况**：游戏引擎需要通过 `tree.instantDestroy()` 方法来触发完整的销毁流程，该方法会：

- 调用 `performTreeFall()` 设置正确的状态
- 设置 `stump = true`, `health = 5`, `falling = true`
- 允许 `tickUpdate` 方法处理倒下动画
- 动画结束后保留树桩对象（而不是删除）

### 核心问题2：同时设置 `falling` 和 `stump` 导致状态冲突

**错误做法**：手动同时设置 `tree.falling = true` 和 `tree.stump = true`。

**问题**：游戏引擎在处理倒下动画结束时，发现对象既在倒下又是树桩，导致逻辑混乱，最终删除整个对象。

**正确做法**：让 `instantDestroy()` 方法自己设置这些状态，确保状态转换的时序正确。

### 核心问题3：穿透子弹的重复击中

**问题**：穿透投射物在击中树木后继续飞行，可能多次触发同一树木的碰撞检测，导致：

- 重复掉落物品
- 刚生成的树桩被立即摧毁

**解决**：使用静态 `HashSet<Vector2> _hitTrees` 记录已击中的树木位置，防止重复处理。

### 核心问题4：`_hitTrees` 阻止了树桩的摧毁

**最终Bug**：树木被击中后，位置被加入 `_hitTrees`，但树桩还在同一位置，导致第二次攻击时被拦截。

**修复**：检查时排除树桩：

```csharp
if (!tree.stump.Value && _hitTrees.Contains(tileLocation))
```

## 排查路径

### 尝试1：直接删除 + 设置 falling

```csharp
tree.falling.Value = true;
location.terrainFeatures.Remove(tileLocation);
```

**结果**：无动画，树木直接消失 
**失败原因**：立即删除了对象，`tickUpdate` 无法播放动画

---

### 尝试2：只设置 falling，依赖引擎

```csharp
tree.health.Value = 0f;
tree.falling.Value = true;
// 不删除，让引擎处理
```

**结果**：有动画，但树木几秒后才消失，且不留树桩 
**失败原因**：引擎不知道该如何处理只设置 `falling` 的情况

---

### 尝试3：时间控制的手动删除

```csharp
tree.falling.Value = true;
_fallingTrees[tileLocation] = currentTime;
// 在 update 中检查时间，2.2秒后删除
```

**结果**：不一致，有时能删除，有时不能 
**失败原因**：投射物有生命周期，被销毁后无法继续执行定时删除

---

### 尝试4：全局定时器 + 手动设置树桩

```csharp
tree.falling.Value = true;
tree.stump.Value = true;  // 手动设置
// 从 ModEntry 全局调用清理方法
```

**结果**：动画结束后树桩也消失了 
**失败原因**：同时设置 `falling` 和 `stump` 导致引擎混乱

---

### 尝试5：实例级 `_hitTrees` (非静态)

```csharp
private HashSet<Vector2> _hitTrees;  // 每个投射物独立
```

**结果**：新投射物仍能摧毁树桩 
**失败原因**：每个投射物实例有自己的 HashSet，互不共享

---

### 尝试6：静态 `_hitTrees` + 树桩无敌时间

```csharp
private static HashSet<Vector2> _hitTrees;
private static Dictionary<Vector2, float> _stumpInvincibilityTime;
```

**结果**：树桩生成后无法摧毁  
**失败原因**：树木被击中后位置记录在 `_hitTrees`，树桩在同一位置，第二次攻击被拦截

---

### 尝试7：查阅源代码 + 使用 `instantDestroy`

```csharp
tree.instantDestroy(tileLocation);
```

**结果**：完美的倒下动画和树桩保留 
**成功原因**：使用了游戏原生方法，正确触发了完整的销毁流程

---

### 最终修复：排除树桩的 `_hitTrees` 检查

```csharp
if (!tree.stump.Value && _hitTrees.Contains(tileLocation))
{
    return;  // 只拦截非树桩的重复击中
}
```

**结果**：一切完美
**成功原因**：允许树桩被击中，同时防止树木被重复处理

## 关键教训

1. **优先查阅游戏源代码**：不要猜测游戏引擎的行为，直接查看源代码了解正确的API用法
2. **理解对象生命周期**：树木→倒下中的树→树桩是状态转换，不是对象替换
3. **注意状态标志的组合**：某些状态组合可能导致引擎混乱
4. **静态变量的作用域**：多实例环境下需要慎重使用静态变量
5. **测试边界情况**：不仅测试第一次攻击，也要测试第二次、第三次攻击

# 最终解决方案指南

## 修改文件清单

### 主要修改

- `StardewPvZWeapons\Src\Domain\Weapons\PiercingProjectile.cs` - 核心逻辑修改

### 依赖文件（无需修改）

- `StardewPvZWeapons\Src\Domain\Weapons\ElectricPiercingProjectile.cs` - 继承自 PiercingProjectile
- `StardewPvZWeapons\Src\ModEntry.cs` - Mod入口

## 核心改动说明

### 1. 添加静态击中记录 (PiercingProjectile.cs)

```csharp
// 在类的成员变量区域添加：
// 记录已击中的树木位置（静态，所有投射物共享）
private static HashSet<Vector2> _hitTrees = new HashSet<Vector2>();
```

**作用**：防止同一位置的树木被多次击中和处理。

---

### 2. 树木碰撞处理逻辑 (behaviorOnCollisionWithTerrainFeature 方法)

```csharp
public override void behaviorOnCollisionWithTerrainFeature(
    StardewValley.TerrainFeatures.TerrainFeature t,
    Vector2 tileLocation,
    GameLocation location)
{
    if (!_destructiveMode) return;
    
    var farmer = this.theOneWhoFiredMe.Get(location) as Farmer;
    
    if (t is StardewValley.TerrainFeatures.Tree tree)
    {
        // 1. 如果树木正在倒下，不处理（等待动画完成）
        if (tree.falling.Value)
        {
            return;
        }
        
        // 2. 如果这个位置的树木（非树桩）已被击中，不再处理
        if (!tree.stump.Value && _hitTrees.Contains(tileLocation))
        {
            return;
        }
        
        // 3. 第一次攻击：触发树木倒下
        if (!tree.stump.Value && tree.growthStage.Value >= 5)
        {
            // 记录已击中此位置
            _hitTrees.Add(tileLocation);
            
            // 调用游戏原生方法（会设置 stump=true, health=5, falling=true）
            tree.instantDestroy(tileLocation);
        }
        // 4. 第二次攻击：摧毁树桩/小树/树苗
        else
        {
            // 使用游戏原生方法销毁（自动处理掉落）
            tree.instantDestroy(tileLocation);
            location.terrainFeatures.Remove(tileLocation);
        }
    }
}
```

**关键点**：

- 使用 `tree.instantDestroy()` 而不是手动设置标志位
-  `_hitTrees` 检查时排除树桩（`!tree.stump.Value`）
- 第一次攻击记录位置，第二次攻击移除对象

---

### 3. 使用游戏原生方法处理其他对象 (update 方法)

#### 3.1 大型资源（大石头、大树桩）

```csharp
// 检查 ResourceClumps
foreach (var clump in location.resourceClumps)
{
    var clumpRect = new Microsoft.Xna.Framework.Rectangle(
        (int)clump.Tile.X * 64, 
        (int)clump.Tile.Y * 64,
        clump.width.Value * 64, 
        clump.height.Value * 64
    );
    
    if (clumpRect.Contains((int)currentPos.X, (int)currentPos.Y))
    {
        // 根据类型选择工具
        var tool = clump.parentSheetIndex.Value >= 672 ? 
            (StardewValley.Tool)new StardewValley.Tools.Pickaxe() : 
            (StardewValley.Tool)new StardewValley.Tools.Axe();
        tool.lastUser = farmer;
        
        if (clump.destroy(tool, location, clump.Tile))
        {
            location.resourceClumps.Remove(clump);
        }
    }
}
```

#### 3.2 普通石头

```csharp
if (obj.IsBreakableStone())
{
    // 使用游戏原生方法（包含正确的掉落逻辑）
    location.OnStoneDestroyed(obj.ItemId, (int)tileLocation.X, (int)tileLocation.Y, farmer);
    location.objects.Remove(tileLocation);
    location.playSound("stoneCrack", tileLocation);
    
    if (farmer != null)
    {
        Game1.stats.RocksCrushed++;
    }
}
```

#### 3.3 杂草

```csharp
if (obj.IsWeeds())
{
    obj.cutWeed(farmer);  // 游戏原生方法，自动掉落纤维
    location.objects.Remove(tileLocation);
}
```

#### 3.4 树枝

```csharp
if (obj.IsTwig())
{
    var axe = new StardewValley.Tools.Axe();
    axe.lastUser = farmer;
    
    if (obj.performToolAction(axe))
    {
        location.objects.Remove(tileLocation);
    }
}
```

## 性能考虑

### 内存使用

`_hitTrees` 是静态变量，在整个游戏会话中持续存在。如果玩家摧毁大量树木，可能积累很多位置记录。

**建议优化**（可选）：

```csharp
// 定期清理 _hitTrees（如每天结束时）
private void OnDayEnding(object sender, EventArgs e)
{
    PiercingProjectile._hitTrees.Clear();
}
```

### 碰撞检测性能

ResourceClumps 的遍历在投射物每帧都会执行。如果地图上有大量资源块，可能影响性能。

**当前方案已优化**：

- 使用矩形碰撞检测（高效）
- 找到目标后立即跳出（goto destroyDone）

## 兼容性

### 已测试环境

- Electric Gatling Pea（电能加特林豌豆）
- 普通穿透投射物
- 农场、矿洞、森林等各种地图

### 潜在冲突

- 其他修改树木破坏逻辑的Mod可能冲突
- 修改 ResourceClump 行为的Mod可能冲突

## 后续维护

### 代码维护要点

1. **不要删除 `!tree.stump.Value` 检查** - 这是允许树桩被摧毁的关键
2. **保持 `_hitTrees` 为静态** - 实例级变量无法防止不同投射物的重复击中
3. **始终使用 `tree.instantDestroy()`** - 不要回退到手动设置标志位

### 游戏更新适配

如果星露谷更新后出现问题，检查：

1. `Tree.instantDestroy()` 方法签名是否变化
2. `OnStoneDestroyed` 方法是否仍然存在
3. `ResourceClump.destroy()` 方法行为是否改变

# 开发经验总结

## 知识点总结

### 1. 星露谷树木系统架构

#### Tree对象的生命周期

```
种子(seed) → 树苗(sprout) → 小树(bush) → 成熟树(mature tree) → 倒下的树 → 树桩(stump)
```

**关键属性**：

- `growthStage.Value` - 生长阶段 (0-5)
  - 0: 种子
  - 1-2: 树苗
  - 3-4: 小树/灌木
  - 5+: 成熟树
- `stump.Value` - 是否为树桩
- `falling.Value` - 是否正在倒下
- `health.Value` - 生命值
  - 成熟树: 默认较高
  - 树桩: 5

#### Tree.instantDestroy() 的内部实现

```csharp
public bool instantDestroy(Vector2 tileLocation)
{
    if ((int)growthStage >= 5)
    {
        return performTreeFall(null, 0, tileLocation); // 成熟树或树桩
    }
    if ((int)growthStage >= 3)
    {
        performBushDestroy(tileLocation); // 灌木/小树
        return true;
    }
    if ((int)growthStage >= 1)
    {
        performSproutDestroy(null, tileLocation); // 树苗
        return true;
    }
    performSeedDestroy(null, tileLocation); // 种子
    return true;
}
```

#### performTreeFall() 的关键操作

```csharp
protected bool performTreeFall(Tool t, int explosion, Vector2 tileLocation)
{
    if (!stump)
    {
        location.playSound("treecrack");
        stump.Value = true;       // 标记为树桩
        health.Value = 5f;        // 设置树桩生命值
        falling.Value = true;     // 开始倒下动画
        // ... 设置倒下方向等
    }
    else
    {
        // 树桩被击中时
        health.Value = -100f;
        if (!falling)
        {
            return true; // 告诉调用者移除树桩
        }
    }
    return false;
}
```

#### tickUpdate() 处理倒下动画

每帧调用，当 `falling = true` 时：

```csharp
if (falling)
{
    shakeRotation += (shakeLeft ? -maxShake² : maxShake²);
    maxShake += 0.0015339808f;
    
    if (Math.Abs(shakeRotation) > PI/2)
    {
        falling.Value = false;  // 动画结束
        location.localSound("treethud");
        // 生成掉落物
        // 注意：不删除对象，因为 health=5 (树桩)
    }
}
```

---

### 2. 石头和大型资源系统

#### 普通石头（Object）

**破坏流程**：

1. `Object.performToolAction(Pickaxe)` - 减少健康值
2. 当健康值 <= 0，调用 `GameLocation.OnStoneDestroyed()`
3. `OnStoneDestroyed()` 调用 `breakStone()` 生成掉落物

**关键API**：

```csharp
// 触发破坏和掉落
location.OnStoneDestroyed(obj.ItemId, x, y, farmer);
location.objects.Remove(tileLocation);
Game1.stats.RocksCrushed++;
```

**掉落逻辑**：

```csharp
protected virtual bool breakStone(string stoneId, int x, int y, Farmer who, Random r)
{
    switch (stoneId)
    {
        case "8": // 铜矿石
        case "10": // 铁矿石
        case "12": // 金矿石
        // ... 根据ID掉落不同物品
    }
}
```

#### 大型资源（ResourceClump）

**类型**：

- 600/602: 大树桩/中空原木
- 672/622: 大石头/陨石

**破坏流程**：

```csharp
// 1. 检测碰撞
var rect = new Rectangle(
    (int)clump.Tile.X * 64,
    (int)clump.Tile.Y * 64,
    clump.width.Value * 64,
    clump.height.Value * 64
);

if (rect.Contains(projectilePos))
{
    // 2. 选择工具
    Tool tool = clump.parentSheetIndex >= 672 ? 
        new Pickaxe() : new Axe();
    
    // 3. 销毁并移除
    if (clump.destroy(tool, location, clump.Tile))
    {
        location.resourceClumps.Remove(clump);
    }
}
```

---

### 3. C# 静态变量与实例变量

#### 问题场景

投射物会创建多个实例，每个实例都有独立的生命周期。

#### 错误用法（实例变量）

```csharp
private HashSet<Vector2> _hitTrees = new HashSet<Vector2>();
```

**问题**：

- 投射物A击中树 → 只记录在A的 `_hitTrees` 中
- 投射物B产生 → 有自己的空 `_hitTrees`
- 投射物B可以再次击中同一树 

#### 正确用法（静态变量）

```csharp
private static HashSet<Vector2> _hitTrees = new HashSet<Vector2>();
```

**效果**：

- 所有投射物共享同一个 `_hitTrees`
- 任何投射物击中的树都会记录
- 其他投射物也能看到这个记录 

#### 注意事项

- 静态变量在整个应用生命周期中存在
- 可能需要定期清理（如每天结束时）
- 线程安全问题（星露谷是单线程，无需担心）

---

### 4. 游戏对象的删除时机

#### 错误理解

认为设置 `falling = true` 后，对象会自动消失或转换为树桩对象。

#### 实际机制

1. **对象不会自动替换**：倒下的树和树桩是同一个对象，只是状态改变
2. **删除需要明确调用**：`location.terrainFeatures.Remove(tileLocation)`
3. **引擎会保留必要的对象**：
   - `health > 0` → 保留
   - `health <= 0` 且 `falling = true` → 保留（播放动画）
   - `health = -100` → 删除

#### 时序图

```
击中成熟树
  ↓
instantDestroy()
  ↓
stump=true, health=5, falling=true
  ↓
tickUpdate() 每帧执行
  ↓
动画结束: falling=false
  ↓
对象保留（因为 health=5）
  ↓
第二次击中树桩
  ↓
instantDestroy() 或 performTreeFall()
  ↓
health=-100
  ↓
返回 true → 调用者删除对象
```

---

## 注意事项

### 1. 关于 `_hitTrees` 的使用

####  必须排除树桩

```csharp
// 错误：会阻止树桩被摧毁
if (_hitTrees.Contains(tileLocation))
{
    return;
}

// 正确：允许树桩被击中
if (!tree.stump.Value && _hitTrees.Contains(tileLocation))
{
    return;
}
```

#### ⚠清理时机

如果不定期清理，`_hitTrees` 会无限增长。建议：

```csharp
// 在 ModEntry.cs 中添加
helper.Events.GameLoop.DayEnding += (s, e) => 
{
    PiercingProjectile.ClearHitTrees(); // 需要添加此静态方法
};
```

---

### 2. 关于 `instantDestroy()` 的调用

#### 不要混用手动标志位和 instantDestroy

```csharp
// 错误：会导致状态混乱
tree.health.Value = 0;
tree.falling.Value = true;
tree.stump.Value = true;  // 不要手动设置！
tree.instantDestroy(tileLocation);

// 正确：只调用 instantDestroy
tree.instantDestroy(tileLocation);
```

#### ⚠️ 调用后需要检查返回值

```csharp
bool shouldRemove = tree.instantDestroy(tileLocation);
if (shouldRemove || tree.stump.Value)
{
    location.terrainFeatures.Remove(tileLocation);
}
```

---

### 3. 关于游戏原生方法的使用

掉落物由游戏处理，不要手动添加

```csharp
// 错误：会导致重复掉落
tree.instantDestroy(tileLocation);
Game1.createObjectDebris("(O)388", x, y, ...); // 不要手动添加木材！

// 正确：只调用原生方法
tree.instantDestroy(tileLocation);
```

#### ⚠某些方法需要传入工具实例

```csharp
// ResourceClump 需要工具才能计算技能加成
var tool = new Axe();
tool.lastUser = farmer;  // 必须设置！
clump.destroy(tool, location, tile);
```

---

### 4. 关于穿透投射物的特殊性

#### 投射物不会自动销毁

普通投射物击中物体后会被销毁，但穿透投射物会继续飞行。这导致：

- 可能多次触发同一对象的碰撞
- 需要额外的防重复机制

#### 碰撞检测持续触发

```csharp
// 投射物可能连续多帧都在同一对象的碰撞范围内
// 需要在第一次处理后立即 return，避免重复处理

if (alreadyProcessed)
{
    return;  // 关键！
}
```

---

### 5. 关于调试技巧

#### 添加日志追踪状态

```csharp
ModEntry.Log($"Tree hit: stump={tree.stump.Value}, falling={tree.falling.Value}, health={tree.health.Value}");
```

#### 查看游戏源代码

使用反编译工具（如 ILSpy, dnSpy）查看：

- `StardewValley.TerrainFeatures.Tree`
- `StardewValley.Object`
- `StardewValley.GameLocation`

#### 对比原版斧头的行为

查看 `Axe.DoFunction()` 了解原版如何处理树木破坏。

---

## 扩展知识

### 如何适配其他类型的投射物

#### 爆炸类投射物

```csharp
public override void behaviorOnCollisionWithTerrainFeature(...)
{
    if (isExplosive)
    {
        tree.performTreeFall(null, explosionPower, tileLocation);
    }
    else
    {
        tree.instantDestroy(tileLocation);
    }
}
```

#### 魔法类投射物

```csharp
// 可以添加特殊效果
tree.instantDestroy(tileLocation);
// 播放魔法效果
location.temporarySprites.Add(new TemporaryAnimatedSprite(...));
```

### 如何支持自定义掉落物

```csharp
// 在 instantDestroy 之后添加额外掉落
tree.instantDestroy(tileLocation);

// 添加魔法木材掉落（示例）
if (hasMagicBonus)
{
    Game1.createObjectDebris("(O)CustomMagicWood", x, y, ...);
}
```

---

## 性能优化建议

### 1. 避免不必要的遍历

```csharp
// 低效：每帧都遍历所有 ResourceClumps
foreach (var clump in location.resourceClumps.ToList())

// 高效：找到目标后立即跳出
foreach (var clump in location.resourceClumps)
{
    if (found)
    {
        goto done;
    }
}
done:;
```

### 2. 缓存farmer引用

```csharp
// 重复获取
var farmer = this.theOneWhoFiredMe.Get(location) as Farmer;
// ... 使用
var farmer2 = this.theOneWhoFiredMe.Get(location) as Farmer;

// 只获取一次
var farmer = this.theOneWhoFiredMe.Get(location) as Farmer;
// 重复使用 farmer
```

### 3. 定期清理静态数据

```csharp
// 防止内存泄漏
if (_hitTrees.Count > 1000)
{
    _hitTrees.Clear();
}
```